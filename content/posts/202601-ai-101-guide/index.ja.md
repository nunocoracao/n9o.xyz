---
title: "AI入門：2026年のAI完全ガイド"
summary: "AIについて知っておくべきすべて - ニューラルネットワークからエージェント、MCPまで - 人間のために解説。完全な初心者でも、バズワードを理解したい開発者でも、このガイドは基礎から理解を深めていきます。"
description: "AIについて知っておくべきすべて - ニューラルネットワークからエージェント、MCPまで - 人間のために解説。完全な初心者でも、バズワードを理解したい開発者でも、このガイドは基礎から理解を深めていきます。"
categories: ["Tech", "AI"]
tags: ["AI", "machine learning", "LLMs", "tutorial", "agents", "MCP"]
date: 2026-02-01
draft: false
showTableOfContents: true
---

{{< lead >}}
AI用語は混沌としています。毎週のように新しい略語、新しい機能、革新的な何かを達成したと主張する新しい企業が登場します。このガイドはノイズを排除し、第一原理から理解を構築します - 完全な初心者であれ、AI製品を評価しようとしているPMであれ、バズワードを解明したい開発者であれ。
{{< /lead >}}

まず基礎から始めて、順を追って進んでいきましょう。

---

## 基礎

### 入れ子の円：AI vs ML vs ディープラーニング

おそらく見たことがある図：AIが外側、機械学習（Machine Learning）が中央、ディープラーニング（Deep Learning）がコアにある3つの同心円。使い古された図ですが、これらの用語の関係を理解するのに本当に役立ちます。

**人工知能（Artificial Intelligence、AI）**は最も広い用語です。これは単に「人間がやれば知能が必要なことをコンピュータにさせる」という意味です。それだけです。1970年代のチェスプログラム？AI。スパムフィルター？AI。ポップアップを表示するかどうかを決める単純なif-elseルール？技術的にはAI。この用語は単独ではほとんど意味がないほど広いです。

**機械学習（Machine Learning、ML）**はAIの*サブセット*で、明示的なルールをプログラムする代わりに、コンピュータに例を与えてパターンを見つけさせます。「メールに『ナイジェリアの王子』が含まれていたらスパムにする」と書く代わりに、「スパム」または「スパムではない」とラベル付けされた10,000通のメールを見せて、アルゴリズムに何がスパムを...スパムたらしめているのかを学習させます。

**ディープラーニング（Deep Learning）**は機械学習の*サブセット*で、多くの層を持つニューラルネットワークを使用します（だから「ディープ（深い）」）。2010年代に面白くなったのはここからです。ディープラーニングは画像認識、音声認識、そして最終的には私たちが今夢中になっている言語モデルのブレークスルーを可能にしました。

{{< alert icon="lightbulb" >}}
**なぜ重要なのか？** 誰かが「AIを使っている」と言っても、ほとんど何も分かりません。「ディープラーニングモデルをファインチューニングした」と言えば、はるかに具体的です。これらの層を理解することで、より良い質問ができ、嘘を見抜けるようになります。
{{< /alert >}}

### ニューラルネットワーク：実際には何なのか

不完全だけど役立つアナロジー：ニューラルネットワークは何百万もの調整可能な数値を持つ非常に複雑なスプレッドシートのようなものです。

データは片側から入ります。それはこれらの数値で乗算され、加算され、いくつかの数学的関数を通過し、最終的に反対側で出力を生成します。「学習」の部分は、出力が望むものと一致するまでこれらすべての数値を調整することです。

より深く知りたい場合：ネットワークは層に組織化されています。各層には「ニューロン」（実際には単なる数学関数）が含まれています。各ニューロンは入力を受け取り、重みで乗算し、合計し、活性化関数を通して結果を渡します。魔法は多くの層を重ねたときに起こります - ネットワークは人間が手でプログラムできないほど信じられないほど複雑なパターンを学習できるのです。

「ニューラル」という用語は、脳の生物学的ニューロンへの緩いアナロジーから来ています。これを文字通りに受け取らないでください。これらのシステムは実際の脳とはまったく異なる方法で動作します。このメタファーは1940年代の元の研究者にとっては有用でしたが、やや誤解を招くものになっています。

{{< alert icon="circle-info" >}}
**重要な洞察：** ニューラルネットワークは万能関数近似器です。十分なニューロンと適切なトレーニングがあれば、任意の数学関数を近似することを学習できます。だからこそ非常に強力で、言語翻訳や画像生成などができるのです - たとえそれらの能力を誰も明示的にプログラムしていなくても。
{{< /alert >}}

### トレーニングと推論：2つのフェーズ

すべてのAIシステムには2つの異なるフェーズがあり、これらを混同すると無限の誤解が生じます。

**トレーニング**は高価な部分です。これはモデルに何百万（または何十億）もの例を見せ、モデルがそのタスクに習熟するまですべての内部数値を調整するときです。GPT-4のトレーニングには計算だけで1億ドル以上かかったと報告されています。トレーニングは一度（またはモデルを更新したいときに定期的に）行われます。

**推論**は比較的安価な部分です。これは実際にトレーニングされたモデルを*使用*するときです。入力を与えると、出力が生成されます。ChatGPTとチャットするたびに、推論を行っています。モデルの数値は固定されており、計算を実行しているだけです。

教育と仕事のように考えてください。トレーニングは何年もの学校と勉強です。推論は仕事に行って学んだことを使うことです。投資は前払いで行われ、見返りは使用中に得られます。

{{< alert icon="lightbulb" >}}
**なぜ重要なのか？** この区別はAI業界について多くを説明します。トレーニングには大規模な資本投資が必要です（だからフロンティアモデルを構築できる企業は少数です）。推論コストがAPI価格が存在する理由であり、AIをローカルで実行することが魅力的な理由です。「AIコスト」について話すとき、トレーニングなのか推論なのかを明確にしてください - まったく異なる経済モデルです。
{{< /alert >}}

---

## LLMを理解する

### LLM：何が違うのか

大規模言語モデル（Large Language Models、LLM）はテキストを予測するようにトレーニングされた特定のタイプのディープラーニングモデルです。これが核心の洞察です：本質的に、LLMはシーケンス内の次の単語（またはトークン）を予測しようとしているだけです。

"猫はマットの上に___" → "座った"（おそらく）

しかし、驚くべきことは：インターネット、本、コード、科学論文からの*何兆もの*単語でこの単純な目的をトレーニングすると、驚くべきことが起こります。モデルは文法だけでなく、事実、推論パターン、コーディング規約、さらには常識のように見える何かを学習します。

これは**創発的行動**と呼ばれます - 明示的にトレーニングされていないが、トレーニングの規模から生まれた能力。誰もGPT-4に詩を書いたり数学の問題を解いたりするようにプログラムしていません。これらの能力は、次のトークンを本当に、本当にうまく予測するという目的から創発しました。

### トランスフォーマーとアテンション

現代のLLMを可能にしたアーキテクチャは**トランスフォーマー**と呼ばれ、有名な「Attention Is All You Need」という2017年の論文で紹介されました。

重要なイノベーションは**アテンションメカニズム**です。以前のモデルはテキストを順番に処理していました - 単語ごとに、左から右へ。アテンションにより、モデルは*すべての*単語を同時に見て、どの単語が互いに関連しているかを学習できます。

簡単な例："その動物は疲れすぎていたので道路を渡らなかった。"

「その」は何を指しているでしょうか？動物です。しかし、モデルはどうやって知るのでしょうか？アテンションメカニズムは「その」が「動物」に強く注目し、「道路」に弱く注目すべきことを学習します。この長距離の依存関係を捉える能力が、トランスフォーマーを言語に対してこれほど強力にしています。

{{< alert icon="fire" >}}
**率直な意見：** トランスフォーマーアーキテクチャは21世紀で最も重要な発明の1つです。これはチャットボットだけの話ではありません - 現在、生物学（AlphaFold）、ロボティクス、ビデオ生成などに適用されています。このアーキテクチャが何ができるかはまだ発見中です。
{{< /alert >}}

### トークンとコンテキストウィンドウ

LLMは実際には単語を見ません - **トークン**を見ます。トークンはテキストの塊で、通常は単語または単語の一部です。「Understanding」は1つのトークンかもしれませんし、「un」+「derstand」+「ing」はモデルのトークナイザーによっては3つのトークンかもしれません。

なぜこれが重要なのでしょうか？モデルには限られた**コンテキストウィンドウ** - 一度に処理できるトークンの最大数 - があるからです。初期のGPT-3は4Kトークンのコンテキストを持っていました。GPT-4 Turboは128Kに拡張されました。Claudeは200Kを処理できます。一部の新しいモデルは数百万を主張しています。

コンテキストウィンドウはモデルの作業メモリと考えてください。モデルに考慮させたいすべてのもの - 質問、共有しているドキュメント、会話履歴 - はこのウィンドウに収まる必要があります。

| モデル | コンテキストウィンドウ | おおよその換算 |
|-------|---------------|------------------|
| GPT-3 (2020) | 4Kトークン | 約3,000語 |
| GPT-4 Turbo | 128Kトークン | 約100,000語 |
| Claude 3.5 | 200Kトークン | 約150,000語 |
| Gemini 1.5 Pro | 100万以上トークン | 約750,000語 |

{{< alert icon="lightbulb" >}}
**なぜ重要なのか？** コンテキストウィンドウのサイズは、モデルで何ができるかを決定します。500ページのドキュメントを分析する必要がありますか？大きなコンテキストウィンドウが必要です。チャットボットを構築しますか？小さなウィンドウで大丈夫ですが、会話メモリの戦略が必要です。トークン制限はコストにも影響します - 処理されたトークンごとに支払います。
{{< /alert >}}

### プロンプトとプロンプトエンジニアリング

**プロンプト**はLLMに送信するテキストです。質問、指示、提供するコンテキスト - すべてプロンプトの一部です。

**プロンプトエンジニアリング**は、より良い結果を得るプロンプトを書く技術（そしてますます科学）です。質問を「エンジニアリング」するなんて馬鹿げているように聞こえますが、本当に重要です。

効果的なテクニック：
- **具体的に。** 「詩を書いて」vs.「気候変動についてシェイクスピア風の14行のソネットを書いて」 - 後者ははるかに良い結果を得ます。
- **例を示す。** 実際の出力を求める前に、望むものの例をいくつかモデルに与えます。これは「few-shot prompting」と呼ばれます。
- **ステップバイステップで考える。** 複雑な問題の前に「これをステップバイステップで考えてみましょう」と追加すると精度が向上します。これは「chain-of-thought」プロンプティングと呼ばれます。
- **役割を割り当てる。** 「あなたは専門の税理士です」はモデルの応答を焦点化します。

{{< alert icon="circle-info" >}}
**プロンプトエンジニアリングは過大評価されている？** 少しだけ。モデルは不正確なプロンプトを理解することが上手くなっています。しかし、本番アプリケーションでは、慎重なプロンプト設計はまだ大きな違いを生みます。魔法ではありません - 明確なコミュニケーションです。
{{< /alert >}}

### 温度とその他のパラメータ

LLM APIを使用するとき、出力に影響を与えるいくつかのパラメータを調整できます。最も重要なのは**温度（temperature）**です。

温度はランダム性を制御します。温度0では、モデルは常に最も確率の高い次のトークンを選択します - 決定論的、予測可能、時には退屈。温度1以上では、確率の低いトークンを選ぶ意欲が高まります - より創造的、より多様、時にはナンセンス。

- **温度0：** 「フランスの首都はパリです。」
- **温度1：** 「フランスの首都はパリ、革命とロマンスが石畳の通りを踊る壮大な光の都市です...」

その他の一般的なパラメータ：
- **Top-p（核サンプリング）：** どのトークンを考慮するかを制限することでランダム性を制御する別の方法。
- **Max tokens：** 応答の長さ。
- **Stop sequences：** モデルに生成を停止するタイミングを伝えます。
- **Frequency/presence penalty：** 繰り返しを減らします。

{{< alert icon="lightbulb" >}}
**実践的なアドバイス：** 事実に基づくタスク、コード、精度が重要なものには低い温度（0-0.3）。クリエイティブライティング、ブレインストーミング、バリエーションが欲しいときには高い温度（0.7-1.0）。普遍的に「正しい」設定はありません。
{{< /alert >}}

### ハルシネーション：なぜ起こるのか

LLMは物事をでっち上げます。完全な自信を持って虚偽を述べます。存在しない論文を引用します。統計を捏造します。これは**ハルシネーション（幻覚）**と呼ばれ、修正されるバグではありません - これらのモデルの動作方法の結果です。

覚えておいてください：LLMは真実のテキストではなく、もっともらしいテキストを予測するようにトレーニングされています。モデルのトレーニングデータが限られているトピックについて質問すると、*正しく聞こえる*何かを生成します。モデルには内部のファクトチェッカーがなく、真実への接続がなく、「分かりません」と言う方法がありません。

なぜこれが起こるのでしょうか？
1. **トレーニング目的：** 真実を検証するのではなく、次のトークンを予測する。
2. **確率分布：** モデルは可能性からサンプリングします。正しい答えが最も可能性が高くても、サンプリングは別のものを選ぶかもしれません。
3. **知識カットオフの認識がない：** モデルはその知識の境界を確実に知りません。

ハルシネーションを減らす戦略：
- RAGを使用して実際のドキュメントに応答を基づかせる
- モデルにソースを引用させ、それを検証する
- 事実に基づくタスクには温度を下げる
- 応答を制約する構造化された出力を使用する
- ファクトチェック層を実装する

{{< alert icon="triangle-exclamation" >}}
**これは難しい問題です。** 何年もの研究にもかかわらず、ハルシネーションは解決されていません。検証なしに重要なことにLLMの出力を信頼しないでください。これは悲観主義ではありません - エンジニアリングのベストプラクティスです。
{{< /alert >}}

---

## モデルの状況

### オープンソース vs クローズドソースモデル

**クローズドソース：** APIを介してモデルを使用できますが、重み、アーキテクチャの変更、自分での実行はできません。OpenAIのGPT-4、AnthropicのClaude、GoogleのGemini。

**オープンソース/オープンウェイト：** 重みは公開されています。ダウンロード、ローカル実行、ファインチューニング、変更ができます。MetaのLlama、Mistral、AlibabaのQwen、DeepSeek、その他多数。

区別は重要ですがニュアンスがあります：
- 「オープンウェイト」はモデルをダウンロードして実行できることを意味します
- 「オープンソース」は伝統的にトレーニングコードとデータも利用可能であることを意味します（大規模モデルではまれ）
- ライセンスは様々です - 一部のオープンモデルには商用制限があります

なぜMetaはLlamaを無料で公開するのでしょうか？戦略的な理由：補完物のコモディティ化、エコシステムの構築、人材の獲得、標準の設定。皮肉な見方：APIの収益でOpenAIと競争できないので、モデル層を無料にして他の場所で利益を得ることで競争しています。

{{< alert icon="fire" >}}
**率直な意見：** オープン vs クローズドの議論は過大評価されています。ユースケースに合うものを使ってください。オープンモデルはコスト管理、カスタマイズ、プライバシーに優れています。クローズドモデルは多くの場合より優れた能力を持ち、開始が簡単です。ほとんどの本番システムは両方を使用します。
{{< /alert >}}

### マルチモーダルモデル

初期のLLMはテキストのみを理解しました。**マルチモーダルモデル**は複数のタイプのデータ - テキスト、画像、音声、ビデオ - を理解します。

GPT-4Vは写真を見て説明できます。Claudeはチャートや図を分析できます。Geminiはビデオを見ることができます。これは単なる目新しさではありません - まったく新しいユースケースを開きます：

- バグのスクリーンショットを撮ってデバッグの助けを求める
- 手書きの図をアップロードしてコードを取得する
- 医療画像を分析する
- コンテンツモデレーションのためにビデオを処理する
- 別々の音声テキスト変換なしの音声インターフェース

アーキテクチャは様々です。一部のモデルはネイティブにマルチモーダルとしてトレーニングされています。他のモデルは別々のビジョンモデルと言語モデルを接続します。この区別はパフォーマンスには重要ですが、ほとんどのユーザーには関係ありません。

{{< alert icon="circle-info" >}}
**マルチモーダルが面白くなるところ：** ロボティクスと具現化AI。モデルが世界を見て物理的なアクションを取れるようになると、新しい領域に入ります。これは初期段階ですが急速に進歩しています。
{{< /alert >}}

### 推論モデル

標準的なLLMは明示的な「思考」なしにトークンごとに応答を生成します。**推論モデル**は異なるアプローチを取ります - 回答する前に問題を考え抜くために追加の計算を費やします。

OpenAIのo1とo3モデルがこのアプローチを開拓しました。すぐに応答する代わりに、これらのモデルは内部推論チェーン（ユーザーには見えないことがある）を生成し、複数のアプローチを検討し、最終的な回答を生成する前に作業をチェックします。

結果は印象的です：推論モデルは数学、コーディング、科学、論理問題で標準的なLLMを劇的に上回ります。o3は何年も先だと思われていた特定のベンチマークでスコアを達成しました。

{{< alert icon="circle-info" >}}
**仕組み：** これらのモデルは問題解決戦略を開発するために強化学習でトレーニングされています。問題をステップに分解し、中間結果を検証し、行き詰まったときにバックトラックすることを学びます。すぐに答えることと、紙の上で問題を解く時間を取ることの違いと考えてください。
{{< /alert >}}

トレードオフ：推論モデルは遅く、より高価です。GPT-4がすぐに答える簡単な質問でも、o1が「考える」と数秒（そして10倍のコスト）かかるかもしれません。単純なタスクでは、それは無駄です。難しい問題には、価値があります。

**推論モデルを使うとき：**
- 複雑な数学や論理問題
- 複数ステップのコーディングチャレンジ
- 慎重な分析が必要なタスク
- 速度よりも精度が重要なもの

**標準的なLLMがより良いとき：**
- シンプルなQ&A
- クリエイティブライティング
- リアルタイムアプリケーション
- コスト重視のユースケース

### 消費者向けAI製品

技術的な詳細に深入りする前に、おそらくすでに使用した製品をマッピングしましょう：

**ChatGPT**（OpenAI） - 主流のAIの波を始めた製品。GPT-4、o1、画像用のDALL-E、各種プラグインへのアクセス。他のすべてが比較されるベンチマーク。

**Claude**（Anthropic） - 強力なライティング、長いコンテキストウィンドウ、ニュアンスのある推論で知られています。Claude.aiは消費者向けインターフェース；APIは多くのアプリケーションを動かしています。

**Gemini**（Google） - Googleのエコシステムと深く統合されています。gemini.google.comを介してアクセスし、Search、Docs、Gmail、Androidにますます組み込まれています。

**Copilot**（Microsoft） - 製品全体にわたるMicrosoftのAI層。GitHub Copilot（コーディング）とは異なります - これはWindows、Edge、Microsoft 365の消費者向けアシスタントです。

**Perplexity** - AIネイティブの検索エンジン。引用とソースで質問に答えます。検索がどうなるかの一端を垣間見せています。

**他に知っておくべきもの：** Grok（xAI、X/Twitterに統合）、Pi（Inflection）、Le Chat（Mistral）、DeepSeek Chat、および多くの地域/専門的な代替品。

{{< alert icon="lightbulb" >}}
**状況は常に変化しています。** 新機能は毎週リリースされます。各製品の背後にあるモデルはしばしば予告なしに変更されます。単一の製品に執着しすぎないでください - いくつか試して、ニーズに合うものを使用してください。
{{< /alert >}}

---

## モデルをローカルで実行する

### なぜローカルで実行するのか？

**クラウドモデル**は他の誰かのサーバーで実行されます。インターネット経由でリクエストを送信し、使用量に応じて支払います。OpenAI、Anthropic、Google - これが彼らのビジネスです。

**ローカルモデル**は自分のハードウェアで実行されます。ノートパソコン、サーバー、データセンター。データは決して管理外に出ません。

なぜローカルで実行するのでしょうか？
- **プライバシー：** 機密データはオンプレミスに留まる
- **コスト：** API料金なし（ただしハードウェアは無料ではない）
- **レイテンシー：** ネットワークラウンドトリップなし
- **可用性：** オフラインで動作、レート制限なし
- **コントロール：** 利用規約なし、選択しなかったコンテンツフィルターなし

ローカルとクラウドのギャップは劇的に縮小しました。多くの実用的なアプリケーションでは、ローカルモデルで十分です - 特にコーディング、ライティング、分析タスクでは。

トレードオフ：フロンティアの能力にはまだクラウドが必要です。難しい推論タスクで絶対最高のパフォーマンスが必要な場合、GPT-4、Claude、Geminiはクラウドのみです。しかし、そのギャップはリリースごとに縮小しています。

### Ollama

[Ollama](https://ollama.ai)はモデルをローカルで実行するためのデファクトスタンダードになりました。かつては複雑だったプロセスを驚くほど簡単にします。

```bash
# 2つのコマンドでモデルをインストールして実行
ollama pull llama3.2
ollama run llama3.2
```

これだけです。完全にあなたのマシンで実行される有能なLLMとチャットしています。

Ollamaは複雑さを処理します：モデルのダウンロード、メモリ管理、ハードウェアの最適化、CLIとローカルAPIの両方の提供。何十ものモデルをサポートしています - Llama、Mistral、Qwen、Phi、CodeLlama、その他多数。

**主な機能：**
- シンプルなCLIインターフェース
- OpenAI互換API（既存のコードへの簡単なスワップ）
- ワンコマンドダウンロードのモデルライブラリ
- Mac、Linux、Windowsで動作
- 利用可能な場合はGPUアクセラレーション

開発者にとって、OllamaのローカルAPIはローカルモデルに対して開発し、本番用にクラウドAPIに切り替える - またはその逆 - ことを最小限のコード変更で可能にします。

### Docker Model Runner (DMR)

[Docker Model Runner](https://docs.docker.com/desktop/features/model-runner/)はモデル推論をDockerエコシステムに持ち込みます。インフラストラクチャがDockerベースの場合、DMRは自然にワークフローに適合します。

```bash
# Dockerイメージのようにモデルをプルして実行
docker model pull ai/llama3.2
docker model run ai/llama3.2
```

DMRは以下を提供します：
- Dockerネイティブのモデル管理
- Docker Desktopとの統合
- OpenAI互換APIエンドポイント
- GPUサポートと最適化
- モデルデプロイメントのための馴染みのあるDockerワークフロー

Ollamaに対する利点は必ずしも技術的ではありません - 運用上のものです。チームがすでにDockerコンテナで考え、デプロイメントパイプラインがDockerベースの場合、DMRは学習して維持するツールが1つ少なくなります。

{{< alert icon="lightbulb" >}}
**Ollama vs DMR：** どちらもうまく機能します。Ollamaはより大きなコミュニティとモデルライブラリを持っています。DMRはDockerベースのインフラストラクチャとより良く統合されます。多くのチームは両方を使用します - 迅速なローカル実験にはOllama、Dockerベースのデプロイメントにはを使用します。
{{< /alert >}}

### ハードウェアの考慮事項

モデルをローカルで実行するにはハードウェアが必要です。重要なものは以下の通りです：

**GPU vs CPU：** GPUは推論を劇的に加速します。CPUで1回の応答に30秒かかるモデルが、GPUでは2秒かかるかもしれません。Apple Silicon Macはこの境界をぼかします - 統合メモリとNeural Engineにより、ローカル推論に驚くほど有能です。

**メモリ（VRAM/RAM）：** これが通常制限要因です。モデルはメモリに収まる必要があります。7Bパラメータモデルは約4-8GB必要です。70Bモデルは35-70GB必要です。量子化（後述）はこれらの要件を削減します。

**量子化：** モデルの重みの精度を32ビットから16ビット、8ビット、または4ビットに削減すること。これによりメモリ要件が縮小し、品質の低下を最小限に抑えて推論が高速化されます。ほとんどのローカルモデルは量子化された形式（GGUF、GPTQ、AWQ）で配布されています。

**実践的なガイダンス：**
- **16GB以上のRAMを持つMac：** 7B-13Bモデルを快適に実行できます
- **32GB以上のRAMを持つMac：** 30B以上のモデルを実行できます
- **RTX 3090/4090（24GB VRAM）を持つPC：** ほとんどの70Bまでのモデルを実行できます（量子化）
- **GPUなし：** まだ動作しますが、遅くなります。開発と実験には問題ありません。

---

## カスタマイズと知識

### ファインチューニング vs RAG：2つのアプローチ

ベースのLLMがあります。特定のユースケースに合わせてより良くしたい。主に2つのアプローチがあります：

#### ファインチューニング

既存のモデルを取り、自分のデータで引き続きトレーニングします。モデルの重みが実際に変わります。ファインチューニング後、モデルはあなたの情報をネイティブに「知って」います。

**利点：** 高速推論、知識の深い統合、新しいスタイルや動作を学習できる。
**欠点：** 高価、MLの専門知識が必要、知識が古くなる可能性、壊滅的忘却のリスク（モデルが他のタスクで悪化する）。

#### RAG（検索拡張生成）

モデルはそのまま維持します。質問が来たら、まず関連するドキュメントのためにナレッジベースを検索し、それらのドキュメントを質問と一緒にプロンプトに含めます。

**利点：** 安価、知識は最新の状態を維持、トレーニング不要、監査が容易（何が検索されたか見える）。
**欠点：** 遅い（2ステッププロセス）、コンテキストウィンドウによって制限、検索品質が非常に重要。

{{< alert icon="fire" >}}
**ほとんどの企業が実際に行うこと：** RAG。ファインチューニングはかっこよく聞こえますが、RAGはほとんどのユースケースでより実用的です。ファインチューニングはモデルの*動作方法*（スタイル、フォーマット、特定のスキル）を変更する必要があるときに優れています。RAGはモデルが*知っていること*を変更する必要があるときに優れています。
{{< /alert >}}

### エンベディングとベクターデータベース

これはRAGを機能させる技術です - そして本当に賢いです。

**エンベディング**はテキスト（または画像、または何でも）を数値のリスト - ベクトル - として表現する方法です。魔法：似たものは似たベクトルを持ちます。「犬」と「子犬」は近いベクトルを持ちます。「犬」と「民主主義」は離れています。

エンベディングモデルを使用してエンベディングを作成します（LLMとは異なりますが、一部のLLMにはエンベディング機能があります）。OpenAI、Cohere、Voyage、および他の多くがエンベディングAPIを提供しています。BGEやE5などのオープンソースオプションもうまく機能します。

**ベクターデータベース**はこれらのベクトルを保存および検索するために最適化されたデータベースです。「返金ポリシーは何ですか？」と質問すると、システムは：
1. 質問をベクトルに変換する
2. ベクターデータベースで類似のベクトルを検索する
3. それらのベクトルが表すドキュメントを返す
4. それらのドキュメントを質問とともにLLMにフィードする

人気のあるベクターデータベースには、Pinecone、Weaviate、Chroma、Qdrant、Milvusがあります。pgvectorを使用したPostgresは多くのユースケースで驚くほどうまく機能します。

{{< alert icon="lightbulb" >}}
**なぜ重要なのか？** エンベディングは最も有用なAIプリミティブの1つです。RAG以外にも、セマンティック検索、レコメンデーションシステム、重複検出などを動かしています。AIで何かを構築している場合、どこかでエンベディングを使用する可能性があります。
{{< /alert >}}

---

## 評価

### ベンチマーク：モデルの能力を測定する

あるモデルが別のモデルより「優れている」かどうかをどうやって知りますか？ベンチマークは標準化されたタスクでモデルをテストすることでこれに答えようとします。

**一般的なベンチマーク：**
- **MMLU（Massive Multitask Language Understanding）：** 57科目にわたる多肢選択問題。一般知識をテスト。
- **HumanEval：** コーディング問題。プログラミング能力をテスト。
- **GSM8K：** 小学校レベルの算数の文章問題。数学的推論をテスト。
- **HellaSwag：** 日常的な状況についての常識的推論。
- **TruthfulQA：** モデルが説得力のあるナンセンスではなく真実の回答を与えるかをテスト。

**ベンチマークの問題：** ゲーム化できます。モデルは実際のタスクで改善することなく、人気のあるベンチマークでうまくいくように特別にトレーニングできます。MMLUで90%をスコアするモデルが、あなたの特定のユースケースではまだ失敗するかもしれません。

{{< alert icon="circle-info" >}}
**ベンチマークの飽和：** 多くの古いベンチマークは「飽和」しています - トップモデルが非常に高いスコアを出すため、差別化する余地がありません。この分野は常に新しい、より難しいベンチマークを必要としています。だから数ヶ月ごとに新しいベンチマーク名を見るのです。
{{< /alert >}}

### 評価（Evals）：なぜ重要なのか

**評価（Evals）**は特定のユースケースのために作成するテストです。ベンチマークとは異なり、評価はアプリケーションにとって実際に重要なことを測定します。

カスタマーサービスボットを構築していますか？評価は以下をテストするかもしれません：
- FAQからの質問に正しく答えるか？
- 必要なときに適切に人間にエスカレーションするか？
- ブランドに沿って、トーンガイドラインに従うか？
- 会社が守れない約束をすることを拒否するか？

**評価が重要な理由：**
1. **回帰検出：** プロンプトを変更したりモデルを切り替えたりするとき、評価はユーザーより先に問題をキャッチします。
2. **比較：** ユースケースに対して異なるモデル、プロンプト、アプローチを客観的に比較します。
3. **イテレーション：** 測定できないものは改善できません。評価は改善を体系的にします。

**良い評価を構築する：**
- 実際のユーザークエリと期待される応答から始める
- エッジケースと敵対的な例を含める
- モデルがすべきこととすべきでないことの両方をテストする
- すべての変更で評価を実行できるように自動化する

{{< alert icon="lightbulb" >}}
**実践的なアドバイス：** シンプルに始めましょう。50の手作業で厳選されたテストケースでも、評価がないよりはるかに良いです。失敗モードを発見するにつれて評価セットを拡大してください。評価の実行を開発ワークフローの一部にしてください。
{{< /alert >}}

### LLM as a Judge（審査員としてのLLM）

賢いテクニックがあります：あるLLMを使用して別のLLMの出力を評価します。

数百の応答を手動でレビューする代わりに、モデルに審査員として行動するようプロンプトできます：

```
あなたはAIアシスタントの応答の品質を評価しています。

ユーザーの質問：{question}
アシスタントの応答：{response}

応答を以下の基準で評価してください：
1. 正確性（1-5）：情報は正確ですか？
2. 有用性（1-5）：実際にユーザーを助けていますか？
3. 明確さ（1-5）：理解しやすいですか？

理由を説明してから、スコアを提供してください。
```

**なぜこれが機能するか：**
- 何千もの評価にスケールする
- 人間のレビュアーより一貫性がある（疲労が少ない）
- プログラムでテストするのが難しいニュアンスのある品質を評価できる
- 人間の評価より安価で速い

**制限：**
- 審査員モデルには独自のバイアスと制限がある
- 自分がするであろうエラーを見逃す可能性がある
- グラウンディングなしではドメイン固有の正確性に苦労する
- 人間の評価の完全な代替ではない - むしろ補完

{{< alert icon="fire" >}}
**メタ質問：** 評価者をどう評価しますか？これはすぐに哲学的になります。実際には、サンプルで人間の判断に対してLLM審査員を検証し、その後評価の大部分で信頼しながら定期的にスポットチェックします。
{{< /alert >}}

---

## エージェントと自動化

### エージェントとは何か？

「エージェント」という用語はよく使われます。ここに実用的な定義があります：**エージェント**は世界でアクションを取ることができるLLMで、単にテキストを生成するだけではありません。

チャットボットは質問に答えます。エージェントは質問に答え*かつ*レストランの予約をし、メールを送信し、データベースをクエリし、問題を解決するためにコードを書いて実行するかもしれません。

何かがただのLLMではなくエージェントである理由は何でしょうか？
1. **目標：** エージェントはプロンプトに応答するだけでなく、目的に向かって働きます。
2. **アクション：** エージェントは言うだけでなく、行うことができます。
3. **自律性：** エージェントは目標を達成する*方法*について決定を下します。
4. **ループ：** エージェントはしばしばループで実行されます - 観察、考え、行動、繰り返し。

最もシンプルなエージェントパターン：LLMにツールへのアクセスを与え、どのツールを使用するか決定させます。「来週のロンドンから東京へのフライトを見つけて、カレンダーをチェックし、スケジュールに合う最も安いオプションを予約してください。」エージェントはこれを分解し、フライトAPIを呼び出し、カレンダーAPIを呼び出し、予約を実行します。

{{< alert icon="fire" >}}
**ここが本当にエキサイティングなところです。** チャットインターフェースは有用ですが限られています。実際に仕事をできるエージェント - それは変革的です。2025-2026年はエージェントが研究デモから本番システムに移行した年でした。
{{< /alert >}}

### エージェント vs ワークフロー

しばしばぼやける重要な区別：

**ワークフロー**は決定論的です。ステップを定義します：まずAをして、次にBをして、Xなら Cをそうでなければ Dをする。LLMは個々のステップを動かすかもしれませんが、オーケストレーションはコード化されています。

```
1. メールからエンティティを抽出（LLM）
2. データベースで顧客を検索（コード）
3. 応答ドラフトを生成（LLM）
4. 人間のレビューに送信（コード）
```

**エージェント**は自律的です。目標とツールを与えると、ステップを自分で見つけ出します。LLMは現在の状態に基づいて次に何をするかを決定します。

```
目標：「この顧客の苦情を解決する」
ツール：[email, database, refund_system, escalation]
→ エージェントが何を、どの順序で行うかを決定
```

**ワークフローを使うとき：**
- 予測可能で、よく理解されたプロセス
- 信頼性と監査可能性が必要なとき
- 規制環境
- 大量、低複雑性のタスク

**エージェントを使うとき：**
- 新規または可変のタスク
- ステップが事前に分からないとき
- 複雑な推論が必要
- 予測可能性よりも柔軟性が重要なとき

**コスト方程式：** ワークフローは大幅に安価です。実行ごとに固定数のLLM呼び出しに対して支払います - 予測可能、最適化可能、監査可能。エージェントは*考える*ので高価です。すべての決定ポイント - 「どのツールを使うべきか？」「それはうまくいったか？」「次は何？」 - はLLM呼び出しです。3回のLLM呼び出しを行うワークフローは、同じ問題を解決するエージェントでは15-30回の呼び出しになるかもしれません。なぜなら、エージェントは*どのように*解決するかについて推論しているからで、事前定義されたステップを実行しているだけではありません。大規模でよく理解されたタスクでは、ワークフローがコストで勝ちます。ステップを事前定義できない複雑で可変な問題では、エージェントはプレミアムの価値があります。

{{< alert icon="circle-info" >}}
**ほとんどの本番システムは両方を使用します。** ワークフローにエージェント的なステップを含めたり、エージェントが決定論的なワークフローをトリガーしたりするかもしれません。二分法は理解に役立ちますが、実際のシステムはハイブリッドです。
{{< /alert >}}

### ツール使用と関数呼び出し

エージェントがアクションを取るには、**ツール** - 呼び出せる関数 - が必要です。この機能は通常**関数呼び出し**または**ツール使用**と呼ばれます。

仕組みは以下の通りです：
1. 名前、説明、パラメータ（通常はJSONスキーマとして）を持つツールを定義する
2. これらの定義をプロンプト/API呼び出しに含める
3. モデルはテキストを生成する代わりにツールを「呼び出す」ことを選択できる
4. あなたのコードが関数を実行し、結果をモデルに返す
5. モデルはそれらの結果を使用して続行する

ツール定義の例：
```json
{
  "name": "get_weather",
  "description": "都市の現在の天気を取得",
  "parameters": {
    "type": "object",
    "properties": {
      "city": {"type": "string", "description": "都市名"},
      "units": {"type": "string", "enum": ["celsius", "fahrenheit"]}
    },
    "required": ["city"]
  }
}
```

「東京の天気は？」と聞くと、モデルはハルシネーションせず - `get_weather(city="Tokyo")`を呼び出し、実際のデータを取得し、事実で応答します。

すべての主要なモデルプロバイダーが関数呼び出しをサポートしています：OpenAI、Anthropic、Googleなど。構文はわずかに異なりますが、コンセプトは同じです。

### MCP：AIのUSB-Cモーメント

**Model Context Protocol（MCP）**はAIモデルをツールやデータソースに接続するためのオープンスタンダードです。AIのためのUSB-Cと考えてください - デバイスごとに異なるケーブルが必要ないユニバーサルコネクタです。

MCP以前は、すべての統合がカスタムでした。AIにGitHubへのアクセスを許可したい？GitHub統合を書く。Salesforce？別の統合。社内データベース？さらに別の統合。これはスケールしません。

MCPはAIクライアント（Claude、ChatGPT、またはカスタムエージェントなど）がMCPサーバーからツールを発見して使用するための標準的な方法を定義します。MCPサーバーは以下を公開するかもしれません：
- **ツール：** AIが呼び出せる関数
- **リソース：** AIが読めるデータ
- **プロンプト：** 一般的なタスクのテンプレート

意味は重要です：
- MCPサーバーを一度構築すれば、互換性のあるすべてのAIが使用できる
- ツールはポータブルで再利用可能になる
- セキュリティと権限を標準化できる
- エコシステムは複合的 - サーバーが増えればより有能なエージェントになる

{{< alert icon="lightbulb" >}}
**なぜ重要なのか？** MCPは重要なインフラストラクチャになりつつあります。Anthropic、OpenAI、Microsoft、Googleはすべてサポートを発表しています。Dockerには100万以上のプルを持つMCPカタログがあります。AIアプリケーションを構築している場合、MCPを理解することはまもなくREST APIを理解することと同じくらい重要になるでしょう。
{{< /alert >}}

MCPについてより詳しくは、私がより深く書いた記事があります：[MCPサーバー：AIエージェントのUSB-Cモーメント](/posts/202504-mcp/)。

### Docker MCPツールキット

Dockerは[Docker MCPツールキット](https://docs.docker.com/ai/mcp-catalog-and-toolkit/)でMCPに傾倒しています - プリビルトのMCPサーバーとそれらを実行するためのツールのカタログです。

MCPカタログには以下のサーバーが含まれています：
- GitHub、GitLab（リポジトリアクセス）
- Slack、Discord（メッセージング）
- PostgreSQL、Redis（データベース）
- ファイルシステム、ウェブブラウジング
- その他多数

なぜこれが重要か：ゼロから統合を構築する代わりに、既存のMCPサーバーを組み合わせてエージェントに能力を与えることができます。エージェントにGitHubとSlackへのアクセスが必要ですか？それらのMCPサーバーをプルし、資格情報を設定すれば完了です。

```bash
# 例：DockerのカタログからMCPサーバーを実行
docker run -d mcp/github --token $GITHUB_TOKEN
```

ツールキットはMCPサーバーの管理、認証の処理、エージェント-ツールのやり取りのデバッグのためのユーティリティも提供します。

### cagent

[cagent](https://github.com/docker/cagent)はDockerのエージェントフレームワークです - MCPを介してツールを使用できるAIエージェントを構築するためのオープンソースツールキットです。

コーディングエージェント（コードを書くことに焦点を当てている）とは異なり、cagentはシステムと対話するエージェントを作成するための汎用フレームワークです。オーケストレーション、ツールの発見、実行ループを処理するので、エージェントが達成すべきことの定義に集中できます。

**主な機能：**
- ツール統合のためのネイティブMCPサポート
- 組み込みの会話と状態管理
- 複数のLLMプロバイダーで動作

外部システム（データベース、API、ファイル）と対話する必要があるカスタムエージェントを構築している場合、cagentはゼロから構築するのではなく、堅固な基盤を提供します。

### エージェントパターン

エージェントが成熟するにつれて、一般的なパターンが現れてきました：

**ReAct（推論+行動）：** エージェントは推論（「ユーザーの注文履歴を見つける必要がある」）と行動（注文APIを呼び出す）を交互に行います。この明示的な推論ステップは信頼性を向上させます。

**計画：** 行動する前に、エージェントは計画を作成します：「これを解決するには、1）注文を検索し、2）在庫を確認し、3）返金を処理し、4）確認を送信する必要があります。」計画は実行前に検証できます。

**リフレクション：** タスクを完了した後（または失敗した後）、エージェントは何が起こったかをレビューします：「注文が古すぎたため返金が失敗しました。最初に返金ポリシーを確認すべきでした。」これにより学習と自己修正が可能になります。

**ツール選択：** エージェントに多くのツールがあるとき、適切なものを選ぶことは簡単ではありません。テクニックにはツールの説明、few-shotの例、階層的なツール組織が含まれます。

**ヒューマン・イン・ザ・ループ：** 高リスクのアクションでは、エージェントは続行する前に一時停止して人間の承認を求めることができます。良いエージェントは自分が不確かなときを知っています。

{{< alert icon="circle-info" >}}
**パターンは収束しています。** ほとんどの成功したエージェントはこれらのテクニックの組み合わせを使用しています。LangChain、LlamaIndex、cagentなどのフレームワークはこれらのパターンをエンコードしているので、ゼロから実装する必要はありません。
{{< /alert >}}

---

## コーディングエージェント

### なぜ重要なのか

コーディングエージェントはAIの最も具体的なアプリケーションの1つを代表しています - 実際にコードを書き、そのコードは実際に動作します。これは理論的ではありません；開発者はこれらのツールのおかげでより速く機能を出荷しています。

影響は即座に測定可能です：ボイラープレートに費やす時間が減り、デバッグが速くなり、馴染みのないコードベースの探索が容易になります。多くの開発者にとって、コーディングエージェントはIDEと同じくらい必要不可欠なものになっています。

### 状況

[**Claude Code**](https://docs.anthropic.com/en/docs/claude-code) - Anthropicのターミナルベースのコーディングエージェント。CLIに存在し、コードベース全体を理解し、ファイルを読み、コードを書き、コマンドを実行し、フィードバックに基づいてイテレーションできます。ターミナルで暮らす開発者向けに設計されています。

[**Cursor**](https://cursor.com) - AI支援を中心にゼロから構築されたAIネイティブIDE。単なる自動補完ではありません - コードベースとチャットし、機能全体を生成し、AIにファイル全体にわたる大規模な変更を行わせることができます。AIとのペアプログラミングに最も近いものです。

[**GitHub Copilot**](https://github.com/features/copilot) - オリジナルで最も広く展開されています。自動補完として始まり、チャットに進化し、現在はより大きなタスク用のCopilot Workspaceを含みます。深いGitHub統合。

[**Windsurf**](https://codeium.com/windsurf) - CodeiumのAI IDE、Cursorの代替として位置付けられています。スピードと大規模なコードベースの理解に強い強調。

[**Cody**](https://sourcegraph.com/cody)（Sourcegraph） - コードベースの理解に焦点を当てています。コンテキストが重要な大規模で複雑なコードベースに特に強い。

[**Continue**](https://continue.dev) - 任意のIDEで動作するオープンソースのコーディングアシスタント。自分のモデルを持参（ローカルまたはクラウド）。AI設定を制御したいチーム向けに良い。

[**OpenCode**](https://github.com/opencode-ai/opencode) - Claude Codeのオープンソース代替。ターミナルベース、モデルにとらわれない、コミュニティ主導の開発。

[**Aider**](https://aider.chat) - もう1つの優れたオープンソースターミナルコーディングエージェント。git統合と複数のファイルを一貫して操作する能力で知られています。

{{< alert icon="lightbulb" >}}
**どれを使うべき？** いくつか試してください。それぞれ異なる強みがあります：Cursorはインタラクティブな開発に優れ、Claude Codeはターミナルワークフローと複雑な推論に、Copilotはシームレスなgitとの統合に優れています。多くの開発者はタスクに応じて複数のツールを使用しています。
{{< /alert >}}

---

## ここからどこへ行くか

基礎を一通り見てきました。次はどこへ？

### 何かを構築したい場合：
- **シンプルに始める。** API（OpenAI、Anthropicなど）を使用して、基本的なチャットボットまたはRAGシステムを構築します。最初はスタックを考えすぎないでください。
- **ローカルモデルを試す。** [Ollama](https://ollama.ai)または[Docker Model Runner](https://docs.docker.com/desktop/features/model-runner/)をインストールして、ノートパソコンでLlamaまたはQwenを実行します。驚くほど簡単です。
- **エージェントを探索する。** エージェントシステムを構築するためにLangChain、LlamaIndex、CrewAI、cagentなどのフレームワークをチェックしてください。
- **MCPを学ぶ。** [公式ドキュメント](https://modelcontextprotocol.io)はしっかりしています。DockerのMCPツールキットでローカルでいくつかのMCPサーバーを実行してみてください。
- **早めに評価を構築する。** 何を構築しても、初日から評価を作成してください。後で感謝するでしょう。

### この分野を理解したい場合：
- **研究をフォローする。** ArXivの論文、関心のあるトピックのGoogle Scholarアラート。
- **誇大広告を批判的に読む。** ほとんどの「ブレークスルー」は漸進的です。再現可能な結果と実際のベンチマークを探してください。
- **自分で実験する。** 何がうまくいくかについての直感は、読むことではなく、実践的な経験から来ます。

### 便利なリソース：
- [Hugging Face](https://huggingface.co) - モデル、データセット、そして信じられないほどのコミュニティ
- [Papers With Code](https://paperswithcode.com) - 実装付きの研究論文
- [Ollama](https://ollama.ai) - 非常にシンプルなローカルモデル実行
- [Docker AI](https://docs.docker.com/ai/) - DMR、MCPツールキット、cagent
- [LangChain](https://langchain.com) / [LlamaIndex](https://llamaindex.ai) - LLMで構築するための人気のフレームワーク
- [Model Context Protocol](https://modelcontextprotocol.io) - MCPの仕様とSDK
- [Chatbot Arena](https://chat.lmsys.org) - 人間の投票でモデルを直接比較

---

2026年のAIは同時に過大評価され、過小評価されています。この技術は本当に変革的です - しかし本当に限られてもいます。LLMは物事をでっち上げます。エージェントは脆弱です。コストは高いです。進歩は速いですが不均一です。

最良のアプローチは実用的です：基礎を理解し、実際の問題で実験し、大きな主張には懐疑的でいて、物を構築する。この時代に繁栄する人々は、すべての略語を暗唱できる人ではありません - 実際に動く製品を出荷できる人です。

さあ、何か構築しましょう。
